import chess.pgn
import time

'''rtde_c.poseTrans(feature_coordinates, coordinate_to_transform)
param1: Ursprung des gew채hlten Koordinatensystems in Base Koordinaten
param2: Vektor im gew채hlten Koordinatensystem
ergebnis: gew채hlter Punkt des gew채hlten Koordinatensystems dargestellt bzgl. der Basis
'''


def read_chess_game_uci(chess_pgn):
    game = []
    input_chess = open(chess_pgn)
    chess_game = chess.pgn.read_game(input_chess)
    board = chess_game.board()
    for move in chess_game.mainline_moves():
        game.append(board.uci(move))
        board.push(move)
    return game


def read_chess_game_san(chess_pgn):
    game = []
    input_chess = open(chess_pgn)
    chess_game = chess.pgn.read_game(input_chess)
    board = chess_game.board()
    for move in chess_game.mainline_moves():
        game.append(board.san(move))
        board.push(move)
    return game


def read_chess_game_lan(chess_pgn):
    game = []
    input_chess = open(chess_pgn)
    chess_game = chess.pgn.read_game(input_chess)
    board = chess_game.board()
    for move in chess_game.mainline_moves():
        game.append(board.lan(move))
        board.push(move)
    return game


def chess_board(field, field_width_x=0.054, field_width_y=0.0542):
    coordinates = []
    letters = ["A", "B", "C", "D", "E", "F", "G", "H"]
    numbers = [1, 2, 3, 4, 5, 6, 7, 8]
    split_field = [char for char in field.upper()]
    for counter, character in enumerate(letters):
        if character == split_field[0]:
            coordinates.append(field_width_x/2 + counter * field_width_x)
    for counter, number in enumerate(numbers):
        if number == int(split_field[1]):
            coordinates.append(field_width_y/2 + counter * field_width_y)
    return coordinates


def captured_pieces_type(chess_pgn):
    dict_pieces = {1: "Pawn",
                   2: "Knight",
                   3: "Bishop",
                   4: "Rook",
                   5: "Queen",
                   6: "King"}
    captured = []
    input_chess = open(chess_pgn)
    chess_game = chess.pgn.read_game(input_chess)
    board = chess_game.board()
    for move in chess_game.mainline_moves():
        if board.is_capture(move):
            if board.is_en_passant(move):
                captured.append(dict_pieces[chess.PAWN])
            else:
                captured.append(dict_pieces[board.piece_at(move.to_square).piece_type])
        else:
            captured.append(None)
        board.push(move)
    return captured


def is_capturing_move(chess_pgn):
    capture = []
    input_chess = open(chess_pgn)
    chess_game = chess.pgn.read_game(input_chess)
    board = chess_game.board()

    for move in chess_game.mainline_moves():
        capture.append(board.is_capture(move))
        board.push(move)
    return capture


def is_en_passant_move(chess_pgn):
    en_passant = []
    input_chess = open(chess_pgn)
    chess_game = chess.pgn.read_game(input_chess)
    board = chess_game.board()
    for move in chess_game.mainline_moves():
        en_passant.append(board.is_en_passant(move))
        board.push(move)
    return en_passant


def is_promotion_move(chess_pgn):
    promotion = []
    input_chess = open(chess_pgn)
    chess_game = chess.pgn.read_game(input_chess)
    board = chess_game.board()

    for move in chess_game.mainline_moves():
        if str(move.promotion) == "None":
            promotion.append([False, move.promotion])
        else:
            promotion.append([True, move.promotion])
        board.push(move)
    return promotion


def is_kingside_castling_move(chess_pgn):
    castling = []
    input_chess = open(chess_pgn)
    chess_game = chess.pgn.read_game(input_chess)
    board = chess_game.board()

    for move in chess_game.mainline_moves():
        castling.append(board.is_kingside_castling(move))
        board.push(move)
    return castling


def is_queenside_castling_move(chess_pgn):
    castling = []
    input_chess = open(chess_pgn)
    chess_game = chess.pgn.read_game(input_chess)
    board = chess_game.board()

    for move in chess_game.mainline_moves():
        castling.append(board.is_queenside_castling(move))
        board.push(move)
    return castling


def move_piece(rtde_c, rtde_r, rtde_io_,
               king_size, origin, starting_field,
               ending_field, v_cobot=1, a_cobot=0.3,
               dig_out=4, waiting_time=0.5):
    # getting coordinates of starting and ending field
    coordinates_start = chess_board(starting_field)
    coordinates_end = chess_board(ending_field)

    # move to the coordinates generated by chess_board function; height slightly above king size
    rtde_c.moveL([origin[0] + coordinates_start[0],
                  origin[1] + coordinates_start[1],
                  origin[2] + king_size,
                  origin[3],
                  origin[4],
                  origin[5]],
                 v_cobot, a_cobot)

    # move down so that gripper can take the bottom of the chess piece
    actual_position = rtde_r.getActualTCPPose()
    actual_position[2] -= king_size
    rtde_c.moveL(actual_position, v_cobot, a_cobot)

    # take the piece with gripper
    rtde_io_.setStandardDigitalOut(dig_out, True)
    time.sleep(waiting_time)

    # move higher
    actual_position = rtde_r.getActualTCPPose()
    actual_position[2] += king_size
    rtde_c.moveL(actual_position, v_cobot, a_cobot)

    # move to the coordinates of the ending field
    rtde_c.moveL([origin[0] + coordinates_end[0],
                  origin[1] + coordinates_end[1],
                  origin[2] + king_size,
                  origin[3],
                  origin[4],
                  origin[5]], v_cobot, a_cobot)

    # move down
    actual_position = rtde_r.getActualTCPPose()
    actual_position[2] -= king_size
    rtde_c.moveL(actual_position, v_cobot, a_cobot)

    # deactivate gripper
    rtde_io_.setStandardDigitalOut(dig_out, False)
    time.sleep(waiting_time)

    # move higher
    actual_position = rtde_r.getActualTCPPose()
    actual_position[2] += king_size
    rtde_c.moveL(actual_position, v_cobot, a_cobot)

    # move to origin position
    '''rtde_c.moveL([origin[0],
                  origin[1],
                  origin[2] + king_size,
                  origin[3],
                  origin[4],
                  origin[5]],
                 v_cobot, a_cobot)
'''


def move_piece_field_to_coordinate(rtde_c, rtde_r, rtde_io_,
                                   king_size, origin, starting_field,
                                   ending_coordinate,  # relative to the base coordinate system
                                   v_cobot=1, a_cobot=0.3,
                                   dig_out=4, waiting_time=0.5):
    # getting coordinates of starting field
    coordinates_start = chess_board(starting_field)

    # move to the coordinates generated by chess_board function; height slightly above king size
    rtde_c.moveL([origin[0] + coordinates_start[0],
                  origin[1] + coordinates_start[1],
                  origin[2] + king_size,
                  origin[3],
                  origin[4],
                  origin[5]],
                 v_cobot, a_cobot)

    # move down so that gripper can take the bottom of the chess piece
    actual_position = rtde_r.getActualTCPPose()
    actual_position[2] -= king_size
    rtde_c.moveL(actual_position, v_cobot, a_cobot)

    # take the piece with gripper
    rtde_io_.setStandardDigitalOut(dig_out, True)
    time.sleep(waiting_time)

    # move higher
    actual_position = rtde_r.getActualTCPPose()
    actual_position[2] += king_size
    rtde_c.moveL(actual_position, v_cobot, a_cobot)

    # move to the coordinates generated by chess_board function
    rtde_c.moveL(ending_coordinate,
                 v_cobot, a_cobot)
    # move down
    actual_position = rtde_r.getActualTCPPose()
    actual_position[2] -= king_size
    rtde_c.moveL(actual_position, v_cobot, a_cobot)

    # deactivate gripper
    rtde_io_.setStandardDigitalOut(dig_out, False)
    time.sleep(waiting_time)

    # move higher
    actual_position = rtde_r.getActualTCPPose()
    actual_position[2] += king_size
    rtde_c.moveL(actual_position, v_cobot, a_cobot)


def capture_piece(rtde_c, rtde_r, rtde_io_,
                  king_size, origin, starting_field_attacker, capture_field,
                  substitute_box,  # needs to be in base coordinate system
                  v_cobot=1, a_cobot=0.3, dig_out=4, waiting_time=0.5):
    # getting coordinates of starting field
    coordinates_capture = chess_board(capture_field)

    # move to the coordinates of the capture field; height slightly above king size
    rtde_c.moveL([origin[0] + coordinates_capture[0],
                  origin[1] + coordinates_capture[1],
                  origin[2] + king_size,
                  origin[3],
                  origin[4],
                  origin[5]],
                 v_cobot, a_cobot)

    # move down so that gripper can take the bottom of the chess piece
    actual_position = rtde_r.getActualTCPPose()
    actual_position[2] -= king_size
    rtde_c.moveL(actual_position, v_cobot, a_cobot)

    # take the piece with gripper
    rtde_io_.setStandardDigitalOut(dig_out, True)
    time.sleep(waiting_time)

    # move higher
    actual_position = rtde_r.getActualTCPPose()
    actual_position[2] += king_size
    rtde_c.moveL(actual_position, v_cobot, a_cobot)

    # move to position where the piece has to be put; includes detection of the piece,
    # maybe when capturing theres the need to input the type
    # of piece which is capturing so that the program knows where to put it
    # right now its a box and u have to reposition all pieces after one game
    rtde_c.moveL(substitute_box, v_cobot, a_cobot)

    # deactivate gripper
    rtde_io_.setStandardDigitalOut(dig_out, False)
    time.sleep(waiting_time)

    move_piece(rtde_c, rtde_r, rtde_io_, king_size, origin, starting_field_attacker,
               capture_field)


def kingside_castling_move(rtde_c, rtde_r, rtde_io_,
                           king_size, origin, white):
    if white:
        move_piece(rtde_c, rtde_r, rtde_io_, king_size, origin, "e1",
                   "g1")
        move_piece(rtde_c, rtde_r, rtde_io_, king_size, origin, "h1",
                   "f1")
    else:
        move_piece(rtde_c, rtde_r, rtde_io_, king_size, origin, "e8",
                   "g8")
        move_piece(rtde_c, rtde_r, rtde_io_, king_size, origin, "h8",
                   "f8")


def queenside_castling_move(rtde_c, rtde_r, rtde_io_,
                            king_size, origin, white):
    if white:
        move_piece(rtde_c, rtde_r, rtde_io_, king_size, origin, "e1",
                   "c1")
        move_piece(rtde_c, rtde_r, rtde_io_, king_size, origin, "a1",
                   "d1")
    else:
        move_piece(rtde_c, rtde_r, rtde_io_, king_size, origin, "e8",
                   "c8")
        move_piece(rtde_c, rtde_r, rtde_io_, king_size, origin, "a8",
                   "d8")


def en_passant_move(rtde_c, rtde_r, rtde_io_,
                    king_size, origin, starting_field,
                    ending_field, white, substitute_box):
    move_piece(rtde_c, rtde_r, rtde_io_, king_size, origin, starting_field,
               ending_field)
    if white:
        change_number = int(ending_field[1]) - 1
    else:
        change_number = int(ending_field[1]) + 1

    captured_piece_field = f"{ending_field[0]}{change_number}"

    move_piece_field_to_coordinate(rtde_c, rtde_r, rtde_io_, king_size, origin, captured_piece_field,
                                   substitute_box)


# can only be adjusted if there a possibility to take captured pieces to a certainly predefined position
def promoting_move(rtde_c, rtde_r, rtde_io_,
                   king_size, origin, starting_field, substitute_box):
    move_piece_field_to_coordinate(rtde_c, rtde_r, rtde_io_, king_size, origin, starting_field,
                                   substitute_box)
    # now take the piece u want to replace it with
    # needs to be replaced when having place to put all the captured pieces!!!!


def is_white_colored_piece(chess_pgn):
    color = []
    for i in range(len(read_chess_game_uci(chess_pgn)) + 1):
        if i % 2 == 1:
            color.append(False)
        else:
            color.append(True)
    return color


if __name__ == "__main__":
    print(is_promotion_move("test2.pgn")[0])
